# AUTO-GENERATED BY ISAC INGESTION ENGINE
# DO NOT EDIT MANUALLY

ISAC_CURRICULUM = {
    "Week 1: Foundations of Data Structure Analysis": {
        "context": "Introduction to Abstract Data Types (ADTs), primitive types, and performance metrics. Detailed study of algorithmic complexity using Big O notation, analyzing best-case, average-case, and worst-case scenarios. Focus on asymptotic behavior.",
        "quiz_focus": "Calculating Big O complexity for simple iterative and nested loop algorithms. Differentiation between O(n), O(log n), and O(n^2) growth rates."
    },
    "Week 2: Arrays and Linked Lists": {
        "context": "Exploration of contiguous vs. non-contiguous memory allocation. Detailed implementation of static and dynamic arrays. Comprehensive review of Singly, Doubly, and Circular Linked Lists, including insertion, deletion, and traversal algorithms.",
        "quiz_focus": "Memory usage comparison between arrays and linked lists. Implementation steps for node deletion in a Doubly Linked List, emphasizing pointer manipulation."
    },
    "Week 3: Stacks and Queues": {
        "context": "Defining the LIFO (Last-In, First-Out) principle for Stacks and the FIFO (First-In, First-Out) principle for Queues. Implementation methods using both arrays (potential overflow) and linked lists. Application of stacks for expression parsing (Infix to Postfix conversion).",
        "quiz_focus": "Tracing operations (Push/Pop, Enqueue/Dequeue) on Array-based Stacks and Circular Queues. Understanding stack applications like function call management."
    },
    "Week 4: Recursion and Searching Algorithms": {
        "context": "Principles of recursion, defining the base case and the recursive step. Analysis of recursive solutions, including tail recursion optimization. Introduction to basic searching: Linear Search and Binary Search (iterative and recursive implementations).",
        "quiz_focus": "Writing and analyzing the complexity of recursive functions (e.g., Factorial, Fibonacci). Tracing the steps of Binary Search on a sorted array."
    },
    "Week 5: Hashing and Hash Tables": {
        "context": "Understanding the function of hash maps and the importance of a good hash function. Detailed study of collision resolution techniques: Separate Chaining and Open Addressing (Linear Probing, Quadratic Probing, Double Hashing). Analysis of the load factor (alpha).",
        "quiz_focus": "Applying different probing techniques to resolve collisions given a specific hash function. Calculating the maximum load factor and its impact on performance."
    },
    "Week 6: Basic Tree Structures and Traversal": {
        "context": "Definition of general trees, terminology (root, leaf, height, depth). Focus on Binary Trees and Binary Search Trees (BSTs). Implementation of standard traversal methods: Inorder, Preorder, and Postorder.",
        "quiz_focus": "Constructing a BST from a sequence of inputs. Identifying the traversal order for a given tree structure. Analyzing worst-case search time in a skewed BST."
    },
    "Week 7: Balanced Trees (AVL and Red-Black Overview)": {
        "context": "The necessity of balancing to maintain O(log n) performance. Detailed study of AVL trees, focusing on the calculation of the balance factor and the necessity of single and double rotations (LL, RR, LR, RL). Conceptual introduction to Red-Black Tree properties.",
        "quiz_focus": "Identifying an unbalanced node in an AVL tree. Determining the correct sequence of rotations required to rebalance after an insertion operation."
    },
    "Week 8: Graph Representations and Traversal": {
        "context": "Defining directed and undirected graphs, weighted graphs, and terminology (vertex, edge, degree). Representation methods: Adjacency Matrix versus Adjacency List. Comprehensive study of Breadth-First Search (BFS) and Depth-First Search (DFS).",
        "quiz_focus": "Converting between Adjacency List and Adjacency Matrix representations. Tracing the path sequence and discovery time using BFS and DFS on an arbitrary graph."
    },
    "Week 9: Graph Algorithms (Shortest Paths)": {
        "context": "Focus on algorithms designed to find the shortest path in weighted graphs. Detailed implementation and analysis of Dijkstra's Algorithm for non-negative weights. Introduction to Bellman-Ford Algorithm for handling negative weight cycles.",
        "quiz_focus": "Applying Dijkstra's Algorithm step-by-step to find the shortest path tree from a single source vertex. Identifying the limitations of Dijkstra's algorithm."
    },
    "Week 10: Advanced Sorting Techniques": {
        "context": "Analysis of comparison-based sorting algorithms. Detailed study of MergeSort and QuickSort, focusing on divide-and-conquer principles and complexity. Discussion of algorithm stability and in-place vs. out-of-place sorting.",
        "quiz_focus": "Tracing the partitioning process of QuickSort (selecting a pivot). Deriving the recurrence relation for MergeSort and confirming its O(n log n) complexity."
    }
    # test
    }
